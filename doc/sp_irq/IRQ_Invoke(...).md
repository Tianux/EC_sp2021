# IRQ_Invoke(...)

#### 函数作用

​	回调函数的触发部分

​	从注册中断链表池spIRQ_CbEntries中查找满足irq和flag的所有实体的地址，并实际调用所有的回调函数

#### 函数类型

​	void

#### 输入

| 变量类型           | 变量名称      | 实际意义                                              |
| ------------------ | ------------- | ----------------------------------------------------- |
| IRQn_Type          | irq           | 中断类型，如TIM8_BRK_TIM12_IRQn                       |
| void*              | peripheral    | 外设寄存器的地址，可以用任意外设的名称替换，如TIM1    |
| spIRQ_GetITStatus  | get_it_status | 中断状态获取函数变量，具体见[sp_irq.md](../sp_irq.md) |
| spIRQ_ClearPending | clear_pending | 清除标志位函数变量，具体见[sp_irq.md](../sp_irq.md)   |

#### 输出

​	无

#### 代码流程

​	获得spIRQ_CbEntries[irq]，即irq对应的链表头地址

​	遍历整个链表，执行所有满足触发标志位的回调函数

​	再次回到链表头，遍历整个链表，执行所有清除标志位的clear_pending函数

#### 代码笔记

​	代码存在一个问题

​	如果在实际写代码的时候，忘记或者写错Clear_Pending函数，可能会出现严重的错误，代码实际上是不具备这样的纠错能力的。

​	只是，原先的代码应该也不具备对应的能力。

​	另外，peripheral与get_it_status和clear_pending的对应关系决不能错，换句话说，无法通过变量检查避免出现对应错误的情况

##### 	为什么不能把两个循环合并在一起？

​	因为列表中可能存在多个针对同一中断标志位的不同回调函数，且不一定呈连续排列，所以很难保证当前执行的是最后一个同中断标志位的回调函数。如果清除标志位，将无法执行后续的回调函数。